= Clojure in a nutshell
:copyright: Timothy Pratley
:license: Eclipse Public License http://www.eclipse.org/legal/epl-v10.html
:backend: slidy
:max-width: 45em


== Introductions

== Clojure

* Data
* Functions
* A tool for thought
* Getting stuff done


== Syntax Summary

Everything is a list with the operation at the front.

[style="literal", options="header"]
|===
|Java |Clojure

|int i = 5; |(def i 5)

|if (x == 0)
  return y;
else
  return z;

|(if (zero? x)
  y
  z)

|x * y * z; |(* x y z)

|foo(x, y, z); |(foo x y z)

|foo.bar(x); |(.bar foo x)
|===


== 1. The Clojure Ecosystem

* Libraries are plain old jars
* Clojure is itself a jar
* Clojure can make direct use of other jars
* Easy to deploy


== a. Leiningen

    lein new training
    cd training
    tree
    cat project.clj
    cat src/training/core.clj


== tree

    .
    ├── CHANGELOG.md
    ├── doc
    │   └── intro.md
    ├── LICENSE
    ├── project.clj
    ├── README.md
    ├── resources
    ├── src
    │   └── training
    │       └── core.clj
    └── test
        └── training
            └── core_test.clj


== project.clj

    (defproject training "0.1.0-SNAPSHOT"
      :description "FIXME: write description"
      :url "http://example.com/FIXME"
      :license {:name "Eclipse Public License"
                :url "http://www.eclipse.org/legal/epl-v10.html"}
      :dependencies [[org.clojure/clojure "1.8.0"]])

== src/training/core.clj

    (ns training.core)

    (defn foo
      "I don't do a whole lot."
      [x]
      (println x "Hello, World!"))


== b. The Read Eval Print Loop (REPL)

	$ lein repl

When you type in this code:

    (+ 1 2)

Clojure evaluates it immediately and returns a result:

	=> 3


== c. Editor setup

IntelliJ+CursiveIDE: https://www.jetbrains.com/idea https://cursive-ide.com/userguide/

Lighttable: http://lighttable.com

Browser: https://repl.it/languages/clojure


== d. Exercises

Evaluate some math expressions in the REPL:

* Find the sum of 2 and 3
* What is 31 times 79?
* Divide 10 by 2
* Divide 2 by 10

Create a new project called `training`. Open `src/training/core.clj` with your editor, write some expressions and send them to the REPL:

* Find the sum of 1, 2, and 3
* Send (println "hello world")


== e. Answers

    (+ 2 3)
    => 5

    (* 31 79)
    => 2449

    (/ 10 2)
    => 5

    (/ 2 10)
    => 1/5

    (+ 1 2 3)
    => 6

    (println "hello world")
    => "hello world"


== 2. Clojure Syntax

== a. Primitive data types

Strings are enclosed in double quotes

    "This is a string."

Character literals are preceded by a backslash

    \a \b \c \newline \tab


== Numbers

|===
|Long |`1`
|Double |`3.14`
|BigInteger |`1000000000000N`
|BigDecimal |`1000000000000.1M`
|Exponents |`1e3`
|Ratio |`2/5`
|===

Automatically promoted on overflow.


== Truthiness

Booleans: `true` and `false`.

`nil` means nothing and is considered false in logical tests.

Anything else is truthy.


== b. Lists

    ()

Evaluated as function calls.

    (inc 1)
    => 2

    (quote (1 2))
    => (1 2)

    ‘(1 2)
    => (1 2)


== Sequences

    (seq ‘(1 2 3))
    => (1 2 3)

Lazy


== Symbols

* Begin with an alphabet character
* Can contain numbers and punctuation
* Usually `lowercase-words-hyphenated`


== Resolving symbols

	inc
	=> #object[clojure.core$inc]

	foo
	=> Exception: Unable to resolve symbol foo

	'foo
	=> foo

== Vectors

    [1 2 3 4]

* Order 1 count and lookup by index
* Preferred over lists


== Equality

Identity and by value

    (= [1 2 3] ‘(1 2 3))
    => true

== Maps

    {"Language" "Clojure"
     "Version" 1.5
     "Author" "Rich Hickey"}

* Near constant time lookup
* Tuned to be fast
* Replacement for object fields


== Keywords

    :language

* Shorthand identifiers
* Begin with a colon
* Often used as keys in hashmaps

    {:language "Clojure"
     :version 1.5
     :author "Rich Hickey"}

== Namespaced keywords

    :timothy.example/rect

    ::rect
    => :timothy.example/rect

* shorthand for current namespace


== Sets

    #{1 2 3}

* Near constant time lookup


== Nesting

    {[1 2] {:name "diamond" :type :treasure}
     [3 4] {:name "dragon" :type :monster}}

* A map with vector coordinate keys, and map values


== c. Invoking functions

    (inc 1)
    => 2

* Prefix


== d. Defining vars

    (def x)
    x
    => #object[clojure.lang.Var$Unbound "Unbound: #'user/x"]

    (def x 1)
    x
    => 1

* Global mutable reference (use sparingly)
* Dereferenced when evaluated

== Atoms

Change over time

    (def a (atom 1))
    (swap! a inc)
    @a
    => 2

    (deref a)
    => 2


== e. Let

    (let [x 1]
      (inc x))
    => 2

* Bind symbols to values in a scope
* Shadow existing bindings
* Prefer `let` over `def`


== f. Destructuring (binding forms)

    (let [[x y] [1 2]]
      (+ x y))
    => 3

* Literal data structure containing symbols
* Matches structure


== Destructuring

Avoids extracting substructure manually:

    (defn normalize1 [v]
      (let [x (first v)
            y (second v)
            length (Math/sqrt (+ (* x x) (* y y)))]
        [(/ x length) (/ y length)]))

    (defn normalize2 [[x y]]
      (let [length (Math/sqrt (+ (* x x) (* y y)))]
        [(/ x length) (/ y length)]))


== Destructuring

Available in any binding form

    (for [[k v] m]
      [v k])


== For expressions

    (for [i (range 10)
          :when (odd? i)]
      (* i i))
    => (1 9 25 49 81)


== Variadic functions

Destructured using `&`

    (defn sub [& vs]
      vs)

    (sub 1 2 3 4)
    => (1 2 3 4)

* Variadic means variable number of arguments
* Arity means number of arguments
* We could have just passed a vector instead


== Apply

* Calls a function with a sequence of arguments

    (apply + [1 2 3 4])
    => 10

* Most mathematical functions are variadic:

    (+ 1 2 3)
    => 6


== Destructuring a map

    (:field1 x)
    (:field2 x)

    {:keys [field1 field2]} x

    {f1 :field1, f2 :field2}

    {:strs [label1 label2]} x


== Destructuring a sequence:

    (first x)
    (rest x)

    [a & more]


== Nested destructuring

    (get-in x [:a :b])

    {{b :b} :a}


== More destructuring

    :as x

    :or {field1 "default"}


== g. Namespaces

    (ns training.core
      (:require [clojure.string :as string])
      (:import [java.util Date]))

    (string/upper-case "shout")

* First thing in a file
* Must match path and filename
* `training.core` in `src/training/core.clj`
* `-` replaced with `_` and `.` replaced with `/`
* Other forms exist, but prefer this one


== Programs

* Expressions which are evaluated to results.
* If an expression needs to be compiled, it will be.
* Can be loaded from files or evaluated dynamically.
* Unit of compilation is a form


== h. Regex

    #"pattern"

    (re-seq #"\w+" "the quick brown fox")
    => ("the" "quick" "brown" "fox")


== i. Exercises

Write code into a new file called `src/training/syntax.clj`, and send the lines to the REPL as you enter them.

* Set up the new namespace called `training.syntax`
* Define a var called `message` bound to the string `"greetings"`.
* Print out the value of the var `message`.
* Create a `let` binding that binds the symbol `message` to `"well hello there"`, and prints out `message` inside the `let` block.
* Print out message again, outside of the `let` block.
* Create a let binding that destructures the map
  `{:greeting "good morning", :tone "happy"}`
  and prints the greeting and tone inside the let block.
* Destructure a single map input containing
  `{:greeting "good morning", :tone "happy"}`
  and return a string combining greeting and tone.
  Use the `str` function.


== j. Answers

    (ns training.syntax)
    => nil

    (def message "greetings")
    => #’hello-clojure/message

    (prn message)
    => "greetings"
       nil

Note `prn` and `println` behave slightly differently; `prn` keeps the quotes around strings. This is often useful when experimenting, because you can visually see the type of the values more clearly.

    (let [message "well hello there"]
      (prn message))
    => "well hello there"
       nil

    (prn message)
    => "greetings"

Note that the `message` global var is still the original value.

    (def m {:greeting "good morning", :tone "happy"})

    (let [{:keys [greeting tone]} m]
      (prn greeting tone))
    => "good morning" "happy"

    (defn hi [{:keys [greeting tone]}]
      (str greeting " - " tone))

    (hi m)
    => "good morning - happy"


== 3. Functions

== a. Defining functions

    (defn square [x]
      (* x x))

    (defn square
      "Multiplies a number by itself"
      [x]
      (* x x))

== Functions continued

* All functions return the last expression as a result
* Defn creates a var

    (square 2)
    => 4

* Mathematical operators in prefix notation.

    (+ (square 2) (square 3))
    => 13

* Arguments are evaluated from left to right before the function is called


== Unnamed functions

    (fn [a]
      (inc a))

* "Unnamed" means "anonymous" means "Lambda expression"

    #(inc %)

* Special syntax

    (#(inc %) 1)
    => 2

* Invoked like a named function


== Closures

Function that captures values from the environment.

    (let [who "world"]
      (defn greet []
        (str "Hello " who))

    (greet)
    => "Hello world"


== Functions are values

* Can be passed as arguments to other functions.
* Functions that take a function as an argument are called higher order functions.

    (defn higher-order-function [f]
      (f))

    (higher-order-function greet)
    => "Hello world"


== Map

* Not to be confused with the `hash-map` data structure
* Function that calls a function on every element in a sequence

    (map #(inc %) [1 2 3])
    => (2 3 4)

* Higher order function, first argument is a function.
* Unnamed closures are useful as arguments to higher order functions.

    (let [x 5]
      (map #(+ x %) [1 2 3]))
    => (6 7 8)


== b. Pre- and post-conditions

    (defn f [x]
      {:pre [(pos? x)]
       :post [(neg? %) (int? %)]}
      (- x))

    (f 1)
    => -1

    (f -1)
    => AssertionError Assert failed: (pos? x)

    (f 1.5)
    => AssertionError Assert failed: (int? %)

* Assertions about inputs and outputs of a function.
* Sequence of conditions
* Rarely used.


== Pre/Post drawbacks:

* Syntax is easy to get wrong, no assertion made
* Assertions can be disabled
* Less control over error reporting and handling


== More common

* Check for a condition and throw an exception

    (defn f [x]
      (when-not (pos? x)
        (throw (ex-info "bad input" {:x x}))
      (let [result (- x)]
        (if (and (neg? result) (int? result))
          result
          (throw (ex-info "bad result" {:x x})))

* Or use a schema or spec


== c. Anonymous functions

    (fn [x]
      (inc x))

    ((fn [x]
       (inc x)
     1)
    => 2

    (let [f (fn [x]
              (inc x))]
      (f 2))
    => 3


== Passing a function to another function

    (map inc [1 2 3])
    => (2 3 4)

    (map (fn [x] (* x x)) [1 2 3 4])
    => (1 4 9 16)

* Don't need to create global definitions


== Inlined named functions

    (fn add-one [x]
      (inc x))

    add-one
    => Unable to resolve symbol: add-one in this context

* Does not create a global var
* Documents purpose
* Name appears in stacktraces (searchable clue)
* The function can call itself with the name


== Note that

    (defn f [x]
      (inc x))

Is shorthand for

    (def f
      (fn [x]
        (inc x)))


== d. Function literals

    #(inc %)
    #(+ %1 %2)

Terse but powerful expressions

    (map #(* % %) [1 2 3 4])
    => (1 4 9 16)

Compare with

    (map (fn square [x]
           (* x x))
         [1 2 3 4])
    => (1 4 9 16)

Prefer `(fn)` form: name parameters and purpose


== e. Variadic arguments

    (defn f [& args]
      args)

    (f 1 2 3)
    => (1 2 3)

    (+ 1 2 3 4 5)
    => 15

Disadvantages:

* Causing callers to have to apply
* Bypasses arity checking


== Do not

    (defn f [x & [y]]
      (if y
        (+ x y)
        (inc x)))

Prefer instead

    (defn f
      ([x] (inc x))
      ([x y] (+ x y)))

Multiple arities should be explicitly declared in parenthesis.


== Keyword arguments - do not use

* Clojure supports keyword arguments

    (defn f [x & {:keys [option1 option2]}] ...)
    (f 42 :option2 "value")

* Prevents users from passing a map of options
* Cannot apply a map to a keyword argument function
* Use a map argument instead of keyword arguments

    (defn f [x {:keys [option1 option2]}] ...)
    (f 42 {:option3 "value"})


== f. Exercises

Create a new namespace called `fun-functions`. Define the following functions and call them with some test input:

* A function that computes the square of an input number. What is the square of 55?
* A function that takes a number as input, ensures that the number is less than 100, and returns the square of the square of the input.
* A function that takes two numbers as input, and returns a vector where the first element is the second input, and the second element is the sum of the first and second input.


== g. Answers

    (defn square [x]
      (* x x))
    (square 55)
    => 3025

    (defn square-of-square [x]
      (if (< x 100)
        (square (square x))
        (throw (ex-info "Input too large" {:x x}))))
    (square-of-square 2)
    => 16
    (square-of-square 123)
    => ExceptionInfo Input too large

    (defn fib-step [a b]
      [b (+ a b)]))
    (fib-step 1 1)
    => [1 2]
    (fib-step 1 2)
    => [2 3]
    (fib-step 2 3)
    => [3 5]


== Challenge 1: Corgi Cover eligibility

Insuricorp is about to launch a marketing campaign for a new “corgi cover” policy. Only certain people are eligible to register for “corgi cover”. To be eligible they must own a corgi, live in either Illinois (IL), Washington (WA), New York (NY), or Colorado (CO). You are tasked with building a system to validate applications for the policy.


== Part 1:

Write a function that will take as input a state and corgi-count, and will return a boolean indicating the person’s eligibility for the “corgi cover” policy.

=== Test data:

[style="literal", options="header"]
|===
|Name |State |Corgi count | Existing policy count
|Chloe |IL |1 |0
|Ethan |IL |4 |2
|Annabelle |WY |19 |0
|Logan |WA |2 |1
|===

See `if` `=`


== Part 2:

A focus group of corgi owners has revealed that “corgi cover” needs to be offered at 3 different tiers: “corgi cover silver”, “corgi cover gold”, and “corgi cover platinum”. Platinum is available when covering 7 or more corgis OR covering at least 3 corgis and also having one other policy with Insuricorp. Gold is available when covering at least 3 corgis. Silver is the original “corgi cover” policy. Create a new function that takes an additional argument policy-count and returns a keyword indicating their eligibility.

See `cond`


== Part 3:

The “corgi cover” applications Insuricorp collect contain more information than necessary to determine eligibility. Create a new function that takes as input a single map data structure as input instead of multiple inputs. It should pick out the values that it needs from the input map. Create some test data and feed it to your function. The data should look something like:

    {:name "Chloe", :state "IL", :corgi-count 1, :policy-count 0}


== Part 4:

Insuricorp just merged with Megacorp. Platinum level corgi cover is now offered to people with an existing Megacorp policy as well. Because the company is still restructuring, the policy-count input still only contains Insuricorp data. But a new input has been made available to you which is a map of people to policies.

    {"Chloe" ["secure goldfish"]
     "Ethan" ["cool cats cover" "megasafe"]}

Create a new function that takes as inputs two maps: the application, and the existing policies. It should apply the same logic, but make use of the Megacorp data.


== 4. Testing with clojure.test

== a. Defining tests with deftest

* Tests are just functions
* Can define a test in any file
* Test namespaces are normal Clojure namespaces
* Convention: “test” dir mirrors “src” dir, append _test
* `src/my_namespace.clj` -> `test/my_namespace_test.clj`.

Common to refer all symbols from `clojure.test` for convenience:

    (ns my-namespace-test
      (:require [clojure.test :refer :all]))


== deftest

    (deftest my-test
      (prn "My test ran"))

* Defines a function with no arguments
* To run a single test, just call it

    (my-test)

* To run all the tests from the REPL:

    (run-tests)

    => "My test ran"
       Ran 0 tests containing 0 assertions.
       0 failures, 0 errors.
       {:test 0, :pass 0, :fail 0, :error 0, :type :summary}


== Command line testing

To run all tests in a project from the command line:

    $ lein test

    => "My test ran"
       Ran 0 tests containing 0 assertions.
       0 failures, 0 errors.
       {:test 0, :pass 0, :fail 0, :error 0, :type :summary}


== b. lein-test-refresh

* Leiningen plugin
* Reloads code and re-runs tests when you save a file.

Add lein-test-refresh to your `~/.lein/profiles.clj`:

    {:user {:plugins [[com.jakemccrary/lein-test-refresh "0.22.0"]]}}

Alternatively as a `project.clj` dependency:

    (defproject sample
      :dependencies [[org.clojure/clojure "1.8.0"]]
      :profiles
      {:dev
       {:plugins [[com.jakemccrary/lein-test-refresh "0.22.0"]]}})


== Using lein-test-refresh

Watch for changes from the command line:

	$ lein test-refresh

Change `my-test` to print a new message.
Tests are re-run as soon as you save the file.

	(deftest my-test
	  (prn "My test ran immediately"))

Use lein-test-refresh like a REPL.
Test more.


== c. Assertions with is and are

True assertion:

	(deftest my-test
	  (is (= 2 (inc 1))))

	=> Ran 1 tests containing 1 assertions.
    0 failures, 0 errors.

* Equality: expected value first, actual value second.
* Expected value literal
* Actual call to the function under test.


== False assertion

	(deftest my-test
	  (is (= 1 (inc 1))))

	=> FAIL in (my-test)
    expected: (= 1 (inc 1))
      actual: (not (= 1 2))

Plugins for showing helpful diffs:
* humane
* ultra

== Can use any truthy assertion

    (deftest odd-test
      (is (odd? 1)))

    (deftest create-test
      (is (create-thing)))


== Describing the assertions

    (deftest pythag-test
      (is (= (* 5 5) (+ (* 3 3) (* 4 4)))
        "The square of the hypotenuse
         is equal to the sum of the squares
         of the other two sides"))

== Grouping assertions

    (deftest math-test
      (testing "Basic math"
        (is (odd? 1))
        (is (= 2 (inc 1))))
      (testing "Pythagoras"
        (is (= (* 5 5) (+ (* 3 3) (* 4 4)))
        "The square of the hypotenuse
         is equal to the sum of the squares
         of the other two sides"))


== are

Concisely expresses multiple assertions

    (are [x y] (= x y)
         2 (+ 1 1)
         4 (* 2 2))

Do not use.

* Easy to make an error in the syntax
* Confusing
* Line numbers are not preserved (harder to find the failing test)


== Asserting exceptions

Test that an exception is thrown:

    (defn bad [x]
      (throw (ex-info "oh no" {})))

    (deftest test-exception
      (is (thrown-with-msg? Exception #"oh no"
            (bad 42))))


== d. Test fixtures

    (use-fixtures :once
      (fn print-enter-exit [tests]
        (println "before")
        (tests)
        (println "after")))

* A fixture is just a function
* Takes a test and calls it
* Recall that tests are functions
* Why? Set up and tear down resources (database connections etc)
* Test runner will call the fixture, effectively
  - prints “before”
  - executes the tests in the namespace
  - prints “after”.


== Every vs once

    (use-fixtures :every
      (fn capture-prints [f]
        (with-out-str (f))))

* `:once` execute once per namespace
* `:each` run for every test in the namespace
* This fixture captures output, prevents clutter
* Common use case is when doing database tests
* Wrap the test execution inside a transaction
* Rollback after the test completes
* Avoids the need to clean up data


== e. with-redefs for mocking

Replace any var using with-redefs:

    (defn post [url]
      {:body (str "Hello world")})

    (deftest test-post
      (with-redefs [str (fn [& args]
                           "Goodbye world")]
        (is (= {:body "Goodbye world"}
               (post "http://service.com/greet")))))

* Disable dependencies during the test
* Isolate particular behaviors
* Test response to external failures
* Let does not suffice, `str` is outside of scope


== f. Debugging

Print out an intermediary values.

    (defn shazam [a b]
      (/ 1 (+ a b) (+ a (* a b))))

What is `(+ a (* a b))` evaluating to? `(doto ... (prn))`

    (defn shazam [a b]
      (/ 1 (+ a b) (doto (+ a (* a b)) (prn "***"))))

    (shazam 1 2)
    => 3 "***"
       1/9

* `prn` will not work, always returns `nil`.
* `doto` causes side-effect to occur, and return the original argument.

== doto

Also useful for Java interop

    (doto (new java.util.HashMap)
      (.put "a" 1)
      (.put "b" 2))
    => {"a" 1, "b" 2}

We get the constructed object, with side-effects applied.


== g. Exercises

* Start lein-test-refresh running in your existing project directory.
* Create a new namespace in the “test” directory called `training.core-test`
* Write a function called `pythag` that returns the square root of the sum of squares for two inputs.
* Write a test containing an assertion that exercises your function. Expect `5` when passing `4` and `3` as arguments.
* Write another test case with different inputs.
* Introduce a bug into pythag to make sure your tests discover the problem.
* Fix `pythag` so that all tests pass.
* Copy the test `test-post` from the "with-redefs" section and modify it so that it counts how many times `str` gets called. Call `post` several times and make an assertion about how many times `str` should get called.


== h. Answers

    (defn pythag [a b]
      (Math/sqrt (+ (* a a) (* b b))))

    (deftest test-pythag
      (is (= 5 (pythag 4 3)))
      (is (= 13 (pythag 12 5))))

    (defn post [url]
      {:body (str "Hello world")})

    (deftest test-post
      (let [c (atom 0)]
        (with-redefs [str (fn [& args]
                            (swap! c inc)
                            "Goodbye world")]
          (post "http://service.com/greet")
          (post "http://service.com/greet")
          (post "http://service.com/greet")
          (is (= 3 @c)))))


== 5. Control Flow

* Special forms: Built in primitives, not functions
* `def`, `let`, `quote` and `fn` are special forms
* Don’t evaluate their arguments


== a. Conditionals: if

`if` chooses between two options:

    (if (pos? 1)
      (println "one is positive")
      (println "or is it?"))
    => "one is positive"

* Returns a result
* Only one branch is evaluated
* A function call evaluates all arguments


== Conditionals: when

Execute code only when a condition is met:

    (when (pos? 1)
      (println "one is positive")
      (println "multiple expressions allowed"))
    => "one is positive"
       "multiple expressions allowed"

* When test fails, nothing is evaluated
* When test passes, the entire body is evaluated.
* Returns a result

== Conditionals: cond

Multiple branches

    (def x {:cake 1})

    (cond (= x 1) "one"
          (= x :cake) "the cake is a lie"
          (map? x) "it’s a map!"
          :else "not sure what it is")
    => "it’s a map!"

* `:else` is not special, it just a truthy value.
* See also `condp` and `case` (rarely used)


== b. Recursion

Functions that call themselves are called recursive.

    (defn sum-up [coll result]
      (if (empty? coll)
        result
        (sum-up (rest coll) (+ result (first coll)))))

Tail Call Optimization: Recursion which avoids consuming the stack

    (defn sum-up-with-recur [coll result]
      (if (empty? coll)
        result
        (recur (rest coll) (+ result (first coll)))))

* Recur can only occur where a function returns
* Stack can be discarded


== c. Loops

    (loop [a 0
           b 1]
      (if (< b 1000)
        (recur b (+ a b))
        a))

* Loop establishes bindings
* Allows recur to the start of the loop
* Can be expressed as functions


== d. Exception handling

Special forms `try` `catch` `finally` and `throw`

    (try
      (inc "cat")
      (catch Exception e
        (println "cat cannot be incremented"))
      (finally
        (println "always"))


== e. Comments

Anything following a semicolon is a comment

    ; this is an inline comment
    ;; this is a function level comment

Less common is the comment form:

    (comment anything)

Removal of next form `#_`

    #_(this form is removed)
    #_#_ ignored-1 ignored-2

* Temporarily remove a form when debuggin code
* Looks like a bug eyes emoji

== Commas

Commas are optional and treated as whitespace.

    (= {:a 1, :b 2, :c 3} {:a 1 :b 2 :c 3})

Prefer newlines

    {:a 1
     :b 2
     :c 3}


== f. Exercises

* Create a function that given a test score between 0 and 100 returns a grade A B C D or F for fail.
* Write a function that takes a number and uses a loop to calculate the factorial of that number. Factorial 5 is 1*2*3*4*5.
* Write a new version of factorial that does not use a loop but recursively calls itself.
* Write a loop for the Fibonacci sequence (1 1 2 3 5 8 13) that finds the maximum Fibonacci number less than 100. The sequence is defined by n2 = n1 + n0.


== g. Answers

    (def grade [score]
      (cond (>= score 90) "A"
            (>= score 80) "B"
            (>= score 70) "C"
            (>= score 60) "D"
            :else "F"))
    (deftest grade-test
      (is (= "B" (grade 85))))

    (defn factorial [n]
      (loop [acc 1
             x n]
        (if (<= x 1)
          acc
          (recur (* acc x) (dec x)))))
    (deftest factorial-test
      (is (= 120 (factorial 5))))

    (defn factorial2
      ([n] (factorial2 1 n))
      ([acc n]
       (if (<= n 1)
         acc
         (recur (* acc n) (dec n)))))
    (deftest factorial2-test
      (is (= 120 (factorial2 5))))


    (defn fib [limit]
      (loop [a 1
             b 1]
        (if (>= b limit)
          a
          (recur b (+ a b)))))
    (deftest fib-test
      (is (= 89 (fib 100))))


== 6. Functional Programming

== a. Pure functions and side effects

* Clojure functions always return a value
* Usually a useful value, not just a nil
* Functions for side effects -> discard result
* `(println "hi")` -> nil
* Print to System out `"hi"` occurs as a side-effect
* Contrast with calling `(str "hi" "there")` -> `"hithere"`
* No side-effects occur
* A function with no side-effects is a pure function
* Same input same output
* `rand` is not a pure function
* Returns a useful result, but changes every time
* Distinction between pure functions and side-effect functions

== Pure functions

Desirable because they are:

* easier to reason about
* easier to combine
* easier to test
* easier to debug
* easier to parallelize

== Clojure api

Many pure functions:

    (def v [1 2])
    (conj v 3)
    => [1 2 3]

    v
    => [1 2]

* `conj` does not add something to a vector
* `conj` returns a new vector value
* v remained unchanged
* Manage change explicitly


== Persistent data structures

* Clojure implements efficient immutable data structures
* Creating derivative values is cheap
* Using a Java vector would require duplicating the vector
* Clojure uses shared structure


== Side effects

* Clojure does allow side-effects
* Side effects are useful
  - databases
  - files
  - user interfaces
* Keep side-effects co-located
* See atoms:
  - Pure function to calculate the next state
  - Atom to manage
  - Logic is separate from the side effect


== b. apply

Given 4 numbers we can call

    (max 1 2 5 3)
    => 5

What if you have a sequence of many numbers?

    (def numbers [1 2 3 4 5 6 7])

    (apply max numbers)
    => 7

* Useful when calling variadic functions like max
* Could have reduced over the sequence
* `apply` is more concise and clear about the intent.


== partial

In Clojure we often pass functions as values.
`partial` creates a function that consumes some arguments:

    (partial + 1)

Returns a function that is equivalent to:

    (fn [& args]
      (apply + 1 args))

== partial

Produces a function:

    ((partial + 1) 2 3)
    => 6

    (map (partial / 1) (range 1 5))
    => (1 1/2 1/3 1/4)

We could have instead written:

    (map #(/ 1 %) (range 1 5))
    => (1 1/2 1/3 1/4)


== c. Functions on sequences: map, reduce, and friends

To embrace Clojure is to think in sequences and data structures.


== Sequences

    (cons 1 ())
    => (1)

    (cons 3 (cons 2 (cons 1 ())))
    => (3 2 1)

    (range 10)
    => (0 1 2 3 4 5 6 7 8 9)


== Careful

Clojure can produce infinite sequences

    (range)

* Don't do this in the REPL
* Press control-c to cancel the REPL if you did

Limit the number of items to consume:

    (take 5 (range))
    => (0 1 2 3 4)

    (drop 5 (take 5 (range)))
    => (5 6 7 8 9)

== filter and remove

    (filter odd? [1 2 3 4])
    => (1 3)

    (remove nil? [1 2 nil 3])
    => (1 2 3)

* filter and remove are higher order functions
* They take a function and a sequence
* They return a sequence of values

== Most things are seqable

    (seq #{"a" "b" "c"})
    => ("a" "b" "c")

    (seq "string")
    => (\s \t \r \i \n \g)

    (seq {:a 1, :b 2})
    => ([:a 1] [:b 2])

Clojure collections implement `ISeq`


== Empty sequences

`seq` returns `nil` on empty sequences

    (seq ())
    => nil

    (empty? ())
    => true

Prefer `(seq xs)` over `(not (empty? xs))`


== map

`map` is a function that calls another function for every element in a sequence:

	(map inc [1 2 3 4])
	=> (2 3 4 5)

* `map` `inc` over `[1 2 3 4]`
* The result is a sequence of the increment of each number in `[1 2 3 4]`
* Not to be confused with hash-maps
* Name is similar, behavior is similar keys -> values


== map over multiple sequences

    (map + [1 2 3] [10 10 10])
    => [11 12 13]


== Composing sequences

Sequences can input for other functions:

    (filter odd? (map inc [1 2 3 4]))
    => (3 5)

* The result of `map` `inc` is filtered with `odd?`


== Aggregate with reduce

Reduce takes a function, initial value, and sequence:

    (reduce * 1 [2 3 4])
    => 24

Performs `(* 1 2)`, then `(* 3)`, then `(* 4)`. Multiplication called 3 times.

    (reduce * [1 2 3 4])
    => 24

The initial value can be left out, if so it is the first element.


== reduce

Written in long form:

    (reduce
      (fn [acc x]
        (* acc x))
      (range 1 5))
    => 24

* Step function takes 2 arguments; aggregate and item
* Step function called for every item
* Aggregate returned
* Aggregate can be anything... a map is common


== group-by

    (group-by count ["the" "quick" "brown" "fox"])
    => {3 ["the" "fox"], 5 ["quick" "brown"]}

* Produced a map
* 3 letter words ["the" "fox"]
* 5 letter words ["quick" and "brown"]
* Can we do this with reduce?


== Sequences are loop abstractions

`filter` is like a Java loop:

    for (i=0; i < vector.length; i++)
	    if (condition)
	        result.append(vector[i]);

`map` is like a Java loop:

    for (i=0; i < vector.length; i++)
        result[i] = func(vector[i]);

`reduce` is like a Java loop:

    for (i=0; i < vector.length; i++)
        result = func(result, vector[i]);


== Sequence abstractions

* Names for loops
* Adds to our vocabulary
* Recognize different kinds of loops
* Worth the effort to learn
  - Reasoning more succinctly
  - Communicating more precisely
  - Writing less code that does more


== Sequences and lambda expressions

Recall the special form `#()` for anonymous functions:

    #(< % 3)

Handy for adding small snippets of logic:

	(filter #(< % 3) (range 10))
	=> (0 1 2)

	(map #(if (odd? %) "odd" "even") [1 2 3 4 5])
	=> ("odd" "even" "odd" "even" "odd")

* more concise than loops
* more descriptive than loops
* composable


== Creating sequences

	(range 5)
	=> (0 1 2 3 4)

	(repeat 3 1)
	=> (1 1 1)

	(partition 3 (range 9))
	=> ((0 1 2) (3 4 5) (6 7 8))


== Transpose

    (map vector [1 2 3] [4 5 6])
    => [[1 4]
        [2 5]
        [3 6]]


== Tricky

Common situation in Java:

	for (i=1; i < v.length; i++)
	    print v[i] + v[i-1];
	=> 3 5 7 9

Using the previous value in the sequence.

Can we represent this as a sequence?

Imagine two identical sequences offset slightly:

	  [1 2 3 4 5]
	[1 2 3 4 5]

The overlapping values are the pairs we want.


== map over both sequences

Recall that `map` can take multiple sequences:

    (map + [1 3] [2 4])
    => (3 7)

`rest` is a function which returns the input sequence without its first element:

    (def v [1 2 3 4 5])
    (rest v)
    => (2 3 4 5)

Put them together:

	(map + v (rest v))
	=> (3 5 7 9)

== Visually

	v        => (1 2 3 4 5)
	(rest v) => (2 3 4 5)

* Sequences were of different lengths
* `map +` stopped when the smallest sequence was exhausted
* The result was a new sequence of the pairwise sums:

	(3 5 7 9)

== Sequences beat loops

Better than loops?

* Loop requires comprehend the entire block of code
* Loop bodies grow and change -> more complexity
* Loop “off by one” mistakes
* Testing loops requires invasion
* Duplication of loops to customize similar operations
* Loops are not composable
* Loops are easy to write, but do not provide leverage


== New requirements

Multiply all of those numbers together.

	result = 1;
	for (i=1; i < v.length; i++)
	    result *= (v[i] + v[i-1]);
	=> 945

* Invasive to the imperative loop
* The change occurs inside the loop
* Intertwined


== Sequence solution

Compose `reduce` with the original `map` expression:

	(reduce * (map + v (rest v)))
	=> 945

* `reduce`: Aggregate by multiplication the sequence
* `map`: adding items together from two sequences
* `pairing`: the sequence of elements in v, adjacent to the rest of v

This is dense, but descriptive code... if you know the vocabulary.


== Sequence solution

* Unit test operations
* Unit test the component sequences
* Reuse sequences
* Reason about transformations as composable parts

== Sequences summary

Sequences are loop abstractions that allow you to ignore the implementation details.

* `filter` keeps items in a sequence according to a predicate
* `map` calls a function over input sequence(s)
* `reduce` aggregates a sequence, returns a single value

I invite you to take the “no loops” challenge.

* Spot a loop
* Stop and think about what the loop represents
* Rewrite the loop as sequence operations instead


== d. Threading operators: why?

	(reduce * (filter odd? (map inc v)))
	=> 15

Three layers of function calls are hard to keep in our head.

* Functions offer combinatorial power
* Simple functions + sequence operations
* But be wary of dense code
* Layers make the code cryptic!
* To read this code, work from inside out
* Finding the inside is a challenge


== Solution: order forms inside first

Name intermediary results:

	(let [incs (map inc v)
	      odd-incs (filter odd? incs)]
	  (reduce * odd-incs))
	=> 15

Or use a thread last:

	(->> v
	    (map inc)
	    (filter odd?)
	    (reduce *))
	=> 15

* Unwraps nested function calls
* Avoids naming steps
* Sometimes good, sometimes bad

== Thread first

Similar to thread last, passes value in first position:

    (-> 42 (/ 2) (inc))
    => 22

For empty expressions, the parens are optional:

    (-> 42 (/ 2) inc)
    => 22


== e. Data structures are functions

* Maps are functions
* They delegate to `get`

    (get {:a 1 :b 2} :a)
    => 1

    ({:a 1 :b 2} :a)
    => 1

    (map {:a 1, :b 2} [:a :b])
    => (1 2)


== Keywords are functions

    (:a {:a 1 :b 2})
    => 1

    (map :a [{:a 1} {:a 2} {:a 3}])
    => (1 2 3)

`get` `:a` for each element in a sequence

Instead of

    (map (fn [m] (get m :a)) [{:a 1} {:a 2} {:a 3}])
    => (1 2 3)


== Sets are functions

    (get #{1 2 3} 2)
    => 2

    (#{1 2 3} 2)
    => 2

    (remove #{nil "bad"} [:a nil :b "bad" "good"])


== Vectors are functions

    (get [1 2 3] 0)
    => 1

    ([1 2 3] 0)
    => 1

== Defaults

`get` can be passed a `not-found` value:

    (get {} :a "default")
    => "default

Datastructures as functions do too:

    ({:a 1, :b 2} :c -1)
    => -1


== f. Exercises

* Write a function that takes two inputs, and returns the sum of the numbers in a range between two input integers, including the two input numbers.
* Write a function that produces a sequence of powers of 2: (1 2 4 8 16 …)
* Write a function that takes a string and produces a sequence of characters with no vowels.
* Write a function that produces a sequence: (1 ½ ⅓ ¼ …)
* Write a function that produces a sequence: (1  ½ ¼ ⅛ …)
* Write a function that produces the Fibonacci sequence (1 1 2 3 5 8 13 21)


== g. Answers

    (defn sum-between [a b]
      (apply + (range a (inc b))))
    (sum-between 3 5)
    => 12

    (defn powers-of [n]
      (iterate #(* % n) 1))
    (take 5 (powers-of 2))
    => (1 2 4 8 16)

    (defn shorten [s]
      (remove #{\a \e \i \o \u} s))
    (apply str (shorten "Clojure sets are functions"))
    => "Cljr sts r fnctns"

    (defn fractions []
      (map / (repeat 1) (rest (range))))
    (take 5 (fractions))
    => (1 1/2 1/3 1/4 1/5)

    (defn fraction-powers [n]
      (map / (repeat 1) (powers-of n)))
    (take 5 (fraction-powers 2))
    => (1 1/2 1/4 1/8 1/16)

    (defn fib-step [[a b]]
      [b (+ a b)])
    (defn fib-seq []
      (map first (iterate fib-step [1 1])))
    (take 10 (fib-seq))
    => (1 1 2 3 5 8 13 21 34 55)


== Challenge 2: Processing files

Insuricorp branches collect applications for the “corgi cover” policy and periodically send them to headquarters in a large comma separated text file. You have been tasked with processing the files using the validation logic you built earlier.


== Part 1:

Create a function that opens a file called corgi-cover-applications.csv and converts every row into a data structure and prints it. Next use that data structure as an input to your validation function and print the result. (see slurp, line-seq, clojure.string/split).


== Part 2:

The downstream Insuricorp systems will only be operating on corgi cover applications that pass your eligibility check, but the invalid corgi cover applications need to be sent back to the branches so that they can follow up with the customers on why they are not eligible. Create a new function that opens two output files and writes to them based upon your eligibility check. The files should be called eligible-corgi-cover-applications.csv and ineligible-corgi-cover-applications.csv


== Part 3:

A request has come in from several Insuricorp branches that if a person is ineligible for corgi cover, a short reason be supplied. That way the sales reps don’t have to spend time figuring out what they need to tell the customer. Create a new validation function that instead of returning a boolean, returns nil if no problems are found, or returns a string with the reason if a problem is found. Create a new processing function that splits the applications into two files based on the new validator.


== Part 4:

As part of the Megacorp merger, the downstream systems are converting to JSON format. Create a new function that writes JSON data to a eligible-corgi-cover-applications.json file


== 7. Macros

* Manipulate the operand forms
* Do not evaluate the input forms
* Not functions
* Cannot be passed to other functions

== Macros

`defn` is a macro

    (defn square [x] (* x x))

Expands to a `def` and `fn` form:

    (def square (fn [x] (* x x)))

Macros allow us to extend the syntax of Clojure

* Macro arguments are manipulated at compile time
* Not evaluated
* Less useful than functions
* Cannot be passed to higher order functions


== a. Expanding macros

* Macros expand to produce new code
* The form is expanded at compile time
* Examine the expansion using `macroexpand-1`

    (macroexpand-1 '(defn square [x] (* x x)))
    => (def my-namespace/square
         (clojure.core/fn
           ([my-namespace/x]
            (clojure.core/* my-namespace/x my-namespace/x))))


== b. Defining macros

    (defmacro zen1 [x]
      (println "x:" x) x)

	(zen1 (+ 1 2))
	=> x:(+ 1 2)
	3

vs

    (defn zen2 [x]
      (println "x:" x) x)


	(zen2 (+ 1 2))
	=> x:3
	3

== Macros

The input to `zen1` was a list.

The input to `zen2` was the result of evaluating the list.

Macros are functions with a `:macro` flag set in their metadata

* Causes macros to be passed in the input forms unevaluated
* Caused the result to be evaluated

* For `zen1` `x` was a list
* We returned `x`
* But the final result was `3`
* The list was evaluated as a function call to `+`
* resulting in `3`


== c. Syntax quoting

Special form called syntax-quote.

    `(inc 1)
    => (clojure.core/inc 1)

All symbols in a syntax-quote form get fully qualified.

    `(1 2 ~(+ 1 2) ~@(map inc [3 4 5]))
    => (1 2 3 4 5 6)

Back-quote (```) Unquote (`~`) and Unquote-splicing (`~@`)


== Why fully qualify?

Symbols may have another meaning in the context:

    (defmacro m1 []
      '(inc 1))

    (defmacro m2 []
      `(inc 1))

    (let [inc dec]
      {:m1 (m1)
       :m2 (m2)})

    => {:m1 0, :m2 2}

Syntax quote avoids colliding with the `let` bindings


== Another source of collisions

    (defmacro bad [expr]
      (list 'let '[a 1]
        (list 'inc expr)))

    (bad 0)
    => 1

    (def a 0)
    (bad a)
    => 2

Notice that:

    (macroexpand-1 '(bad a))
    => (let [a 1] (inc a))

The parameter name collided with the implementation.


== Gensyms

Gensyms produce a randomly named binding:

    (defmacro good [expr]
      `(let [a# 1]
         (inc ~expr)))

    (good a)
    => 1

    (good 0)
    => 1

    (macroexpand-1 '(good a))
    => (clojure.core/let [a__6500__auto__ 1] (clojure.core/inc a))

The `let` binding `a#` expands to a randomly generated symbol


== d. Code as data

* Really writing a function that produces code.
* The output is code... as data
* We manipulate code... as data.
* Homoiconic means that the language text has the same structure as its abstract syntax tree (AST).
* Code in the language can be transformed as data using the same representation.
* Nested code is well represented as a data structure.


== Macro stragegy

When working on a non-trivial macro a good strategy is:

* Step 1: Write a function!
* Step 2: Call your function from the macro.

Keep the macro as small. Offload transformations to other functions.


== e. Exercises

Create the following macros and test cases:

* Create a macro called ignore which accepts any number of expressions, does absolutely nothing, and always returns `nil`.

    (ignore (println "hello???") (inc 42))

* Define your own version of the when macro. When is like if, but only has one branch and allows multiple statements.

    (when2 (pos? x)
      (println "Positive:" x)
      (inc x))

* Write a spy macro. Spy wraps an expression and prints out its value.

    (* (spy (+ 1 2)) 3)
    => Expression (+ 1 2) has value 3
       9

* Write your own version of the `or` macro

    (or2 (pos? 1) (println "does not execute"))


== f. Answers

    (defmacro ignore  [expr]  nil)

    (defmacro when2 [test & body]
      (list 'if test (cons ‘do body))


    (defmacro spy [expr]
      `(let [result# ~expr]
         (println "Expression" '~expr "has value" result#)
         result#))
    (macroexpand-1 '(spy (* 2 3)))
    => (clojure.core/let [result__6418__auto__ (* 2 3)]
         (clojure.core/println
           "Expression" (quote (* 2 3))
           "has value" result__6418__auto__)
         result__6418__auto__)
    (+ 1 (spy (* 2 3)))
    => Expression (* 2 3) has value 6
       7

    (defmacro or2
      ([] nil)
      ([x] x)
      ([x & next]
          `(let [or# ~x]
             (if or# or# (or ~@next)))))


== 8. Parallel Programming and Concurrency

== a. Vars and dynamic scope

* Vars are automatically derefed when evaluated
* seem like just a variable
* See the var itself using the var function or #' shorthand.

    (def one-hundred 100)
    => #'training.core-test/one-hundred

    (var one-hundred)
    => #'training.core-test/one-hundred

    (deref #'one-hundred)
    => 100

* Functions defined with defn are stored in Vars
* Allows the re-definition of functions at runtime


== Metadata

Examine the metadata of a var:

    (meta #'one-hundred)
    => {:line 73, :column 1, ...}

Metadata provided using `^{}`

    (def x ^{:private true} 1)

You can attach whatever metadata you wish. These are the keys the compiler looks for:

    :private
    :doc
    :author
    :type


== Dynamic vars

* By default Vars are static
* Can be marked as dynamic to allow per-thread bindings
* Per thread they obey a stack discipline

	(def ^:dynamic x 1)
	(def ^:dynamic y 1)
	(+ x y)
	=> 2

	(binding [x 2 y 3]
	         (+ x y))
	=> 5

	(+ x y)
	=> 2


* Bindings cannot be seen by any other thread
* Bindings can be assigned to


== b. Delays, Futures, and Promises

* Wrap an arbitrary body of code for evaluation
* Executes at a later stage
* Run only if the answer is asked for
* Delays also cache the result value
* Prevents another execution
* Body only runs once, even concurrently


== Delays

    (def d (delay (println "Hello world!") 42))

    d
    => #object[clojure.lang.Delay {:status :pending, :val nil}]

    (realized? d)
    => false

    @d
    => Hello world!
       42

    @d
    => 42

    (realized? d)
    => true


== Futures

* Easy way to spin off a new thread
* Do some computation or I/O
* Access in the future
* Call style is compatible with delay
* Work begins immediately on another thread
* Flow of control is not blocked
* Dereferencing a future will block until the value is available


== Futures

    (def f
      (future (Thread/sleep 10000) 42))

    f
    => #object[clojure.core$future_call {:status :pending, :val nil}]


    (realized? f)
    => false

--- 10 seconds pass ---

    (realized? f)
    => true

    @f
    => 42

    f
    #object[clojure.core$future_call {:status :ready, :val 42}]


== Promises

* Used in a similar way to delay or future
* Dereference them for a value
* Check if they have a value with `realized?`
* Block when you dereference them until they have a value
* Don’t immediately give them a value
* Provide them with one by calling deliver


== Promises

    (def p (promise))
    (realized? p)
    => false

    (deliver p "as-promised")
    (realized? p)
    => true

    @p
    => "as-promised"


== c. Atoms

    (def a (atom 1))
    (swap! a inc)
    @a
    => 2

* Manage shared, synchronous, independent state
* Reference type like refs and vars
* Create an atom with `atom`
* Access state with `deref`/`@`
* Change the value of an atom with `swap!` or `reset!`
* Changes to atoms are always free of race conditions


== Atoms

* Atomic
* `swap!` reads the current value, applies the function to it, and attempts to `compare-and-set!` it in
* Since another thread may have changed the value, it may have to retry
* Retries in a spin loop
* Net effect: the value will always be the result of the function
* Function might be called multiple times, it must be free of side effects.
* Suitable for uncoordinated state
* Synchronous changes


== Refs

    (def r (ref 1))
    (dosync
      (alter r inc))
    @r
    => 2

* Vars ensure safe use of mutable storage locations via thread isolation, transactional references
* Refs ensure safe shared use of mutable storage locations via a software transactional memory (STM) system
* Refs are bound to a single storage location for their lifetime
* Only allow mutation of that location to occur within a transaction
* In practise Refs are rarely used.


== Agents

    (def a (agent 1))
    (send a inc)
    @a
    => 2

    (send-off a (fn [x] (do-some-io))

* Like Refs, Agents provide shared access to mutable state.
* Refs support coordinated, synchronous change of multiple locations
* Agents provide independent, asynchronous change of individual locations.
* `send` should be used for actions that are CPU limited
* `send-off` is appropriate for actions that may block on IO.
* Agents are integrated with the STM


== d. Exercises

See Challenge 3


== 9. Java Interop

== a. Clojure syntax for Java constructors

Constructing a Java object is done by appending a period to the class identifier:

    (ns training.core
      (:import [java.util Date]))

    (Date.)
    (Date. 2018 02 17)

Which is equivalent to the less used variant:

    (new Date)
    (new Date 2018 02 17)


== b. Calling methods

Calling a method on a Java object done by prepending a leading period:

    (.length "hello world")
    (.isDirectory (java.io.File. "my-dir"))

Which is equivalent to the less used variant:

    (. "hello world" length)
    (. (java.io.File. "my-dir") isDirectory)

Java static method calls are accessed by slash:

    (Math/pow 1 2)
    (.print System/out "hi")

Inner classes can be accessed using the dollar symbol:

    java.nio.channels.FileChannel$MapMode/READ_ONLY


== c. reify

`reify` creates an object that conforms to an interface:

    (.listFiles (java.io.File. ".")
      (reify
        java.io.FileFilter
        (accept [this f]
          (.isDirectory f))))

Notice that we did not define a class?


== d. gen-class and proxy

`gen-class` creates a class. In practise the need to create a class from within Clojure is rare, so we won’t be covering the syntax.
(see https://kotka.de/blog/2010/02/gen-class_how_it_works_and_how_to_use_it.html if you want to explore this further)

`proxy` can be used to extend a concrete superclass. Again the need for this is rare.
(see https://kotka.de/blog/2010/03/proxy_gen-class_little_brother.html if you want to explore this further)


== e. Including Java classes in Clojure projects

You can define Java classes in Java in a separate directory and add

    :java-source-paths ["java-src"]

To your `project.clj` file
(See https://github.com/technomancy/leiningen/blob/master/doc/MIXED_PROJECTS.md for more other options.)


== Challenge 3: Mocking parallel web requests

Insuricorp and Megacorp are integrating their IT systems. As part of this effort you need to modify the “Corgi cover” eligibility logic to call a remote web service. Your task is to set up the code and tests.


== Part 1: Mock a web request

Every Insuricorp “Corgi cover” policy application needs to be cross referenced with Megacorp to see if the customer has a Megacorp policy already via a remote web service. The web service is not available for you to test against yet. Set up a function called fetch-megacorp-policies to do the web request but leave the implementation empty. Create a test that changes the behavior of fetch-megacorp-policies to behave as though it were a web request; make it pause for 100ms before returning the policies that the person has. Set up a test that exercises the eligibility checks using the mocked version of a web request.


== Part 2: Report the how long it takes

In Java you might write something like this:

    long startTime = System.nanoTime();
    // ... the code being measured ...
    long estimatedTime = System.nanoTime() - startTime;

Implement a similar solution in Clojure.


== Part 3: Make parallel requests

The web service you are using can handle multiple requests faster than a series of requests. It operates fastest with up to 20 connections. Modify your code such that multiple requests are made simultaneously. Compare the timing results to confirm the operations are happening in parallel.


== Part 4: Error handling

Modify your mock of fetch-megacorp-policies such that it throws an exception randomly about 10% of the time. Make sure your tests report a failure. Now update your logic to handle the errors and retry up to 10 times. The tests should pass. Then create another test where the exception is thrown 100% of the time, and the max tries occurs.


== 10. Polymorphism and Types

== a. Multimethods

Polymorphic dispatch. Define the name of the multimethod and the dispatch function:

    (defmulti encounter
      (fn dispatch [x y]
        [(:species x) (:species y)]))

Provide methods implementing functions to execute for a given dispatch value:

    (defmethod encounter [:bunny :lion] [x y] :run-away)
    (defmethod encounter [:lion :bunny] [x y] :eat)
    (defmethod encounter [:lion :lion] [x y] :fight)
    (defmethod encounter [:bunny :bunny] [x y] :mate)

* Between a case statement and a function definition.
* Conditions under which to be called, and a function definition.
* Given a dispatch result of `[:bunny :lion]`, the first method will be called.
* `x` and `y` are inputs to the function
* unused in this example.


== Multimethods

Test data

    (def bunny1 {:species :bunny, :other :stuff})
    (def bunny2 {:species :bunny, :other :stuff})
    (def lion1 {:species :lion, :other :stuff})
    (def lion2 {:species :lion, :other :stuff})

Call the multimethod

    (encounter bunny1 bunny2)
    => :mate
    (encounter bunny1 lion1)
    => :run-away
    (encounter lion1 bunny1)
    => :eat
    (encounter lion1 lion2)
    => :fight

== Multimethods

Keywords are functions.

It is common to use a keyword as a dispatch function.

    (defmulti draw :shape)


== b. Protocols

A named set of named methods and their signatures:

    (defprotocol AProtocol
      "A doc string for AProtocol abstraction"
      (bar [a b] "bar docs")
      (baz [a] [a b] [a b c] "baz docs"))

* No implementations are provided
* Yields a set of polymorphic functions and a protocol object
* The functions dispatch on the type of their first argument
* Must have at least one argument

deftype, defrecord, or reify support protocols directly:

    (defprotocol P
      (foo [x])
      (bar-me [x] [x y]))

    (deftype Foo [a b c]
      P
      (foo [x] a)
      (bar-me [x] b)
      (bar-me [x y] (+ c y)))

    (bar-me (Foo. 1 2 3) 42)
    => 45

    (foo
     (let [x 42]
       (reify P
         (foo [this] 17)
         (bar-me [this] x)
         (bar-me [this y] x))))
    => 17


== defprotocol

* Dynamic
* Generates a corresponding interface, with the same name as the protocol
* The interface will have methods corresponding to the protocol functions
* The protocol will automatically work with instances of the interface
* A Java client can implement the protocol-generated interface


== extend

    (extend AType
      AProtocol
       {:foo an-existing-fn
        :bar (fn [a b] ...)
        :baz (fn ([a]...) ([a b] ...)...)}
      BProtocol
        {...}
    ...)

* Extends the polymorphism of the protocol’s methods
* Will call the supplied functions when an AType is provided as the first argument
* The `fn` can presume first argument is instanceof `AType`
* You can implement a protocol on `nil`.
* Default implementation of protocol with `Object`.


== extend-type

    (extend-type MyType
      Countable
        (cnt [c] ...)
      Foo
        (bar [x y] ...)
        (baz ([x] ...) ([x y zs] ...)))

Expands into:

    (extend MyType
      Countable
       {:cnt (fn [c] ...)}
      Foo
       {:baz (fn ([x] ...) ([x y zs] ...))
        :bar (fn [x y] ...)})


== c. Creating types with defrecord and deftype

* `deftype`, `defrecord`, and `reify` provide the mechanism for defining implementations of abstractions, and instances of those implementations.
* Resist the urge to use them to define ‘structured data’ as you would define classes or structures in other languages.
* It is preferred to use the built-in datatypes (vectors, maps, sets) to represent structured data.


== deftype

    (deftype Circle [radius])
    (deftype Square [length width])

    (Circle. 10)
    (Square. 5 11)

    (->Circle 10)
    (->Square 5 11)


== defrecord

	(ns training.core
	  (:import (java.net FileNameMap)))

    (defrecord Thing [a]
      FileNameMap
      (getContentTypeFor [this fileName] (str a "-" fileName)))

* Defines a record named `Thing`
* single field `a`
* Implements `FileNameMap` interface
* Implements `String getContentTypeFor(String fileName)`


== record constructor

    (def thing (Thing. "foo"))

    (instance? FileNameMap thing)
    => true

Call the method on the `thing` instance and pass `"bar"`:

    (.getContentTypeFor thing "bar")
    => "foo-bar"


== 11. Specifications with clojure.spec

* Specifies the structure of data
* Validates data structures
* Can generate data
* Introduced into Clojure 1.9.0
* Update `project.clj` to the right version:

	[org.clojure/clojure "1.9.0"]

    (ns training.spec
      (:require [clojure.spec.alpha :as s]))


== a. Validation

    (s/valid? even? 10)
    => true

    (s/valid? string? 0)
    => false

Any single argument function is a valid predicate spec


== Common to use a set

Sets are functions, so can be used as predicates that match one or more literal values:

    (s/valid? #{:club :diamond :heart :spade} :club)
    => true


== Registration

Specs are registered using `s/def`.

    (s/def ::suit #{:club :diamond :heart :spade})

A registered spec identifier can be used in place of a spec definition.

    (s/valid? ::suit :club)
    => true


== Composing specs

    (s/def ::big-even (s/and int? even? #(> % 1000)))

    (s/valid? ::big-even 10)
    => false

    (s/valid? ::big-even 100000)
    => true


== b. Conforming

    (s/def ::name-or-id (s/or :name string? :id int?))

* Involves a choice during validity checking.
* Each choice is tagged (`:name` and `:id`)

    (s/conform ::name-or-id "abc")
    => [:name "abc"]

    (s/conform ::name-or-id 100)
    => [:id 100]


== nil

    (string? nil)
    => false

To include `nil` as a valid value:

    (s/nilable string?)


== explain

Reports why a value does not conform to a spec.

    (s/explain ::big-even 5)
    => val: 5 fails spec: ::big-even predicate: even?

See also `explain-str`


== c. Maps

    (def email-regex
      #"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}$")
    (s/def ::email-type (s/and string? #(re-matches email-regex %)))
    (s/def ::acctid int?)
    (s/def ::first-name string?)
    (s/def ::last-name string?)
    (s/def ::email ::email-type)

    (s/def ::person (s/keys :req [::first-name ::last-name ::email]
                            :opt [::phone]))


== Validating maps

* required attributes are included
* every registered key has a conforming value

    (s/valid? ::person
      {::first-name "Elon"
       ::last-name "Musk"
       ::email "elon@example.com"})
    => true


== Unqualified

    (s/def :unq/person
      (s/keys :req-un [::first-name ::last-name ::email]
              :opt-un [::phone]))

    (s/valid? :unq/person
      {:first-name "Elon"
       :last-name "Musk"
       :email "elon@example.com"})
    => true

* Existing Clojure code not use namespaced keys
* req-un -> required unqualified keys
* opt-un -> optional unqualified keys


== map-of

    (s/def ::scores (s/map-of string? int?))
    (s/valid? ::scores {"Sally" 1000, "Joe" 500})
    => true

* Specifies a map with homogenous key and value predicates


== pre and post conditions

    (defn adder [x]
      #(+ x %))

    (s/fdef adder
      :args (s/cat :x number?)
      :ret (s/fspec :args (s/cat :y number?)
                    :ret number?)
      :fn #(= (-> % :args :x) ((:ret %) 0)))

* `:ret` declares that the returning function takes and returns a number
* `:fn` calling any adder with `0` should return `x`


== d. A game of cards

Model a game of cards:

    (def suit? #{:club :diamond :heart :spade})
    (def rank? (into #{:jack :queen :king :ace} (range 2 11)))
    (def deck (for [suit suit? rank rank?] [rank suit]))

    (s/def ::card (s/tuple rank? suit?))
    (s/def ::hand (s/* ::card))

    (s/def ::name string?)
    (s/def ::score int?)
    (s/def ::player (s/keys :req [::name ::score ::hand]))

    (s/def ::players (s/* ::player))
    (s/def ::deck (s/* ::card))
    (s/def ::game (s/keys :req [::players ::deck]))

    (def kenny
      {::name "Kenny Rogers"
       ::score 100
       ::hand []})
    (s/valid? ::player kenny)
    => true

Bad data produces errors

    (s/explain ::game
      {::deck deck
       ::players [{::name "Kenny Rogers"
                   ::score 100
                   ::hand [[2 :banana]]}]})
    => In: [::players 0 ::hand 0 1]
       val: :banana fails spec: ::card
       at: [::players ::hand 1]
       predicate: suit?


== Restricting deal to valid games

    (defn total-cards [{:keys [::deck ::players] :as game}]
      (apply + (count deck)
        (map #(-> % ::hand count) players)))

    (defn deal [game] ...)

    (s/fdef deal
      :args (s/cat :game ::game)
      :ret ::game
      :fn #(= (total-cards (-> % :args :game))
              (total-cards (-> % :ret))))


== e. Generators

* Specs are designed to act as generators
* Produce sample data that conforms to the spec
* Useful for property-based testing

Spec generators rely on the `test.check` as a development dependency in `project.clj`:

    :profiles {:dev {:dependencies [[org.clojure/test.check "0.9.0"]]}}

    (ns training.spec
      (:require [clojure.spec.gen.alpha :as gen]))


== gen

    (gen/generate (s/gen int?))
    => -959

* `gen` obtains the generator for a spec
* `generated` creates a value that conforms to the spec

    (gen/generate (s/gen ::player))
    => {:spec.examples.guide/name "sAt8r6t",
        :spec.examples.guide/score 233843,
        :spec.examples.guide/hand ([8 :spade] [5 :heart] [9 :club] [3 :heart])}

	(gen/generate (s/gen ::game))
    => {...}


== sample

    (gen/sample (s/gen string?))
    => ("" "" "" "" "8" "W" "" "G74SmCm" "K9sL9" "82vC")

    (gen/sample (s/gen #{:club :diamond :heart :spade}))
    => (:heart :diamond :heart :heart :heart :diamond :spade :spade :spade :club)


== int-in range

    (s/def ::roll (s/int-in 0 11))
    (gen/sample (s/gen ::roll))
    => (1 0 0 3 1 7 10 1 5 0)

See also `inst-in` and `double-in`

`test.check` tutorial https://clojure.github.io/test.check/intro.html


== f. Instrumentation and Testing

    (ns training.spec
      (:require [clojure.spec.test.alpha :as stest]))

    (defn ranged-rand
      "Returns random int in range start <= rand < end"
      [start end]
      (+ start (long (rand (- end start)))))

    (s/fdef ranged-rand
      :args (s/and (s/cat :start int? :end int?)
                   #(< (:start %) (:end %)))
      :ret int?
      :fn (s/and #(>= (:ret %) (-> % :args :start))
                 #(< (:ret %) (-> % :args :end))))


== instrument

    (stest/instrument `ranged-rand)

* Fully-qualified symbol, use ```
* Provides validation for external uses of a function

    (ranged-rand 8 5)
    => CompilerException clojure.lang.ExceptionInfo: Call to #'spec.examples.guide/ranged-rand did not conform to spec

* `unstrument` to turn off.


== check

* Generate arguments based on the `:args` spec
* Invoke the function
* Check that `:ret` and `:fn` specs were satisfied

    (stest/check `ranged-rand)
    => ({:spec #object[clojure.spec.alpha$fspec_impl ...],
         :clojure.spec.test.check/ret {:result true, :num-tests 1000, :seed 1466805740290},
         :sym spec.examples.guide/ranged-rand,
         :result true})

* `ranged-rand` contains a bug
* Run check several times to find it


== enumerate-namespace

    (stest/check (stest/enumerate-namespace 'testing.spec))

* Test all spec’ed functions in a namespace

    (stest/check)

* Check all spec’ed functions


== 12. Interacting with a Database

== a. Intro to clojure.java.jdbc

Database persistence is important for many applications. We can use clojure.java.jdbc to interact with a database.

To start, create a new project

    $ lein new messenger

and add dependencies to your `project.clj` file:

    [org.clojure/java.jdbc "0.7.5"]
    [hsqldb/hsqldb "1.8.0.10"]

Note that we need the driver we plan to use to connect to a database. In this case we are using an in memory HSQL database.

In the Clojure project we require jdbc, and set up a db connection url.

    (ns messenger.core
      (:require [clojure.java.jdbc :as jdbc]))

    (def db "jdbc:hsqldb:mem:testdb")

Now we are all set to start doing queries.


== b. Inserting, updating and retrieving data

First we will create a table called testing inside the database with a text field named data, and then insert some rows.

    (jdbc/execute! db
      "create table messages (message varchar(1024))")

    (jdbc/insert-multi! db :messages
                        [{:message "Hello World"}
                         {:message "How now?"}])

And we can query the data back:

    (jdbc/query db ["select * from messages"])
    => ({:message "Hello World"}
        {:message "How now?"})

To selectively delete some data:

    (jdbc/delete! db :messages ["message like '%World%'"])

And now there is only one row remaining.

    (jdbc/query db ["select * from messages"])
    => ({:message "How now?"})

Let’s add some more data...

    (jdbc/insert-multi! db :messages
                    [{:message "Nobody panic!!!"}
                     {:message "What in the world?"}
                     {:message "All is well."}])

And now we create a function to do a parameterized query.

    (defn search [s]
      (jdbc/query db
        ["select * from messages where message like ?" s]))

    (search "%How%")
    => ({:message "How now?"})

It is important to use parameterized queries instead of string concatenation in this example because it protects us from SQL injection. Parameters are not part of the query, so they cannot perform SQL from malicious input.

If you want to redo any steps, remember that you can always drop the table and start again.

    (jdbc/execute! db "drop table messages")


== c. Solutions for SQL management

HoneySQL https://github.com/jkk/honeysql can be used to build SQL statements from data structures. This is useful when you have to programmatically combine clauses to produce a final SQL statement. For example if the user can check a checkbox to enable an additional clause in a search. In such cases it is more convenient to use Clojure’s capabilities for manipulating data structures. However if you do not need to do such manipulation, I recommend using plain old SQL queries in their original text form, as you can run them interactively from an SQL prompt much easier that way.


== d. Exercises

* Create and populate a table `person` with two columns; `id`, `name`.
* Create and populate a table `policy` with two columns; `id`, `name`
* Create and populate a table `person_policy` with two columns; `person_id`, `policy_id`
* Write a function that given a person name queries all the policies associated with them.


== e. Answers

    (ns messenger.core
      (:require [clojure.java.jdbc :as jdbc]))

    (def db "jdbc:hsqldb:mem:testdb")

    (jdbc/execute! db
      "create table person (id bigint, name varchar(1024))")
    (jdbc/execute! db
      "create table policy (id bigint, name varchar(1024))")
    (jdbc/execute! db
      "create table person_policy
      (person_id bigint, policy_id bigint)")
    (jdbc/insert-multi! db :person
                        [{:id 1 :name "Sally"}
                         {:id 2 :name "Billy"}])
    (jdbc/insert-multi! db :policy
                        [{:id 1 :name "Corgi Cover"}
                         {:id 2 :name "Poodle Protection"}])
    (jdbc/insert-multi! db :person_policy
                        [{:person_id 1 :policy_id 1}
                         {:person_id 1 :policy_id 2}
                         {:person_id 2 :policy_id 1}])

    (defn find-policies [person-name]
      (jdbc/query db ["select a.name
                      from policy a
                      inner join person_policy b
                      on a.id = b.policy_id
                      inner join person c
                      on b.person_id = c.id
                      where c.name = ?"
                      person-name]))

    (find-policies "Sally")
    => ({:name "Corgi Cover"} {:name "Poodle Protection"})
    (find-policies "Jane")
    => ()
    (find-policies "Billy")
    => ({:name "Corgi Cover"})


== Challenge 4: Corgi Cover Database

Sending files around is proving to be problematic. Sometimes applications are lost or the results of the eligibility check are not communicated back to the customer. You have been tasked with creating a central source of truth that can be queried as to what applications have been submitted and processed.


== Part 1: Set up the schema

Using the database of your choice, set up an initial database for the Corgi Cover project. In the code, connect to the database and create the initial table required. You can use whatever schema you like, but the first requirement is to store the applications with exactly the same data as was retrieved from the file format in Challenge 2.


== Part 2: Populate the data

Modify the code to store the applications as they are processed, and the result of the eligibility check.


== Part 3: Write a spec

Ensure that all records processed from the files meets your expectations for required fields. Write a spec that explicitly defines what should be in the applications. Validate the spec on the incoming records.


== Part 4: Extending to Poodle Protection

Insuricorp is about to launch a new policy called “Poodle Protection”. Soon they will be processing applications with completely new rules. Set up a multimethod to handle “Poodle Protection” applications differently from “Corgi Cover” applications. For now the only difference with the rules from “Corgi Cover” is that “Poodle Protection” is available in different states: California (CA), Florida (FL), Wyoming (WY), and Hawaii (HI).


== Further reading

Writing Clojure code requires more thinking and less typing than other languages. Don’t feel frustrated if the code comes slowly at first. Being a great programmer requires thinking. You will only reach your true potential expressing code in ways that empower you rather than constrain you.

Further exercises:	https://www.4clojure.com/

Clojure for Java Programmers - Rich Hickey

* Part 1:		https://www.youtube.com/watch?v=P76Vbsk_3J0
* Part 2:		https://www.youtube.com/watch?v=hb3rurFxrZ8

Hadoop libraries

* https://github.com/nathanmarz/cascalog
* https://github.com/damballa/parkour
* https://github.com/r0man/hdfs-clj

Spark libraries

* https://github.com/yieldbot/flambo


== Best practices

* Write tests
* Write expectation strings for tests
* Use lein-test-refresh
* Keep functions short and focused
  - Extract sub functions
  - Compose functions
* Keep namespaces short and focused
  - Extract related functions into new namespaces
  - Write doc-strings for namespaces
* Write doc-strings for functions
* Write doc-strings for defs when appropriate
* Follow the Clojure style guide


== Tips

* Build bottom up
* Start with data
* Create functions to operated on that data
* Eastwood can give hints on better expressions
* Read source code (Clojure, libraries, open source projects)
* Most problems can be solved with a function
* Scientific method:
  - Think of things that could possibly be wrong
  - Isolate a small test case
  - Test one hypothesis at a time
* Finding Clojure libraries https://www.clojure-toolbox.com/


== Workflow

Editor + Test refresh + REPL

Reading stacktraces
  - Try line 1
  - Scan down for your namespace
  - Might be project/profile

Small functions

Test as you go

Print things

Test assumptions/hypothesis


== Editor customization

* After you feel comfortable with Clojure
* Paredit
* Parinfer
* Send file to REPL
* Send form to REPL


== Read Clojure code

* Clojure source
* Clojure libraries
* Open source projects
* Check the source on anything new you use


== Style guide

https://github.com/bbatsov/clojure-style-guide


== Eastwood

Produces suggestions on how to write idiomatic Clojure

`$HOME/.lein/profiles.clj`

    {:user {:plugins [[jonase/eastwood "0.2.5"]]}}

    $ lein eastwood


== Get help

* Starweaver:
  - paul.siegel@starweaver.com
  - dipika.sinha@starweaver.com
* REPL can answer most questions
* Minimal example
* StackOverflow.com #clojure
* Clojure mailing list https://groups.google.com/forum/#!forum/clojure
* ClojureVerse https://clojureverse.org
* Clojurians Slack http://clojurians.net


== Practice

* Challenges 1-4
* Small projects
* 4Clojure problems http://www.4clojure.com
* Project Euler https://projecteuler.net
* Katas
